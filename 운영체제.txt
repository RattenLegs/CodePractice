크게 3가지

메모리 관리: 배치 전략, 페이징 기법

- 배치 전략: 하나의 프로세스를 통으로 메모리에 넣는 것
- 페이징 기법: 하나의 프로세스를 페이지라는 단위로 쪼개서 가상 메모리에 넣어 작업하는 개념

배치 전략은 프로세스를 통으로 넣고, 페이징 기법은 잘라서 넣는 차이가 있다.

CPU 스케쥴링: 프로세스 연산 할당 방법
CPU가 프로세스를 만날 때 어떻게 프로세스를 줄 세우고 소비(연산)하느냐에 대한 알고리즘

리눅스: 자주 사용되는 명령어

운영체제의 목적

1. 처리능력(Throughput) 향상: 일정 시간 내 시스템이 처리하는 양을 올리기 위해

2. 반환 시간(Turn Around Time) 단축: 시스템 작업 의뢰할때, 처리가 완료될 때까지의 시간이 짧게

3. 사용 가능도(Availability) 향상: 시스템 사용할 필요 있을 때 즉시 사용할 수 있게끔

4. 신뢰도(Reliability) 향상: 정확하게 해결하는 것

메모리 관리(배치전략)

1. 최초 적합
2. 최적 적합
3. 최악 적합

(손필기함)

가상 메모리 관리(페이징 기법)
실행할 프로세스를 page 단위로 잘라서 똑같이 자른 물리 주소 공간(frame)에 할당하는 방법

frame: 실제 물리 메모리에서 공간을 자른 것
page: 운영체제가 임의로 프로세스를 단위에 맞게 자른 것

페이지라는 단위는 계속 교체를 해서 메모리에 올리거나, 디스크에 되돌리거나를 반복한다.

OPT, FIFO, LRU, LFU, MFU, NUR과 같은 방법론이 있다.
메모리에 올라가 있는 잘린 프로세스의 단위를 교체한다고 생각하면 된다.

하나의 운영체제가 프로세스를 관리하는데, 실제 메모리의 양보다 더 큰 양의 프로세스가 들어오는 경우가 있다.

실행 순서대로(참조할 수 있는 단위로 잘라서) 관리하고 사용하지 않는 것은 하드디스크에 넣는 것을 가상메모리 방식이라 함

프로세스: 현재 실행 중인 프로그램, 운영체제가 자원을 할당하고 관리하는 기본 단위로 보면 된다.
운영체제는 각 프로세스에 CPU 연산 시간, 메모리, 파일, 입출력 장치에 대한 자원을 할당해서 작업을 수행한다.

페이지 폴트: 프로그램이 참조하려는 페이지가 현재 메모리에 없다는 것을 칭하는 용어
프레임: 물리적 메모리 주소를 페이지 크기와 맞게 잘라놓은 공간의 단위

OPT(Optimal Page Replacement): 가장 이상적인 것, 향후에 사용하지 않을 거 같은 것을 미리 넣음
맨 마지막까지 100페이지를 한번만 본다고 할 때 중간에 100페이지가 있다고 한다면, 앞에 있는 것보다 뒤에 있는것을 최대한 덜 프레임에 올리려 할 것
미래에 내가 어떤 페이지를 볼 지 알아야 함

7,0,1,2,0,3,0,4,2,3,0,3,2,1, 3칸이에용

701 들어가고 2 들어갈 때 맨 마지막까지 7이 없다는걸 알기 때문에 7 자리에 2를 넣음(fault)
0은 있기 때문에 굳이 또 넣을 필요 없음hit
3을 넣을때는 1이 뒤에 덜 사용되기 때문(맨 끝에 하나만 있음)에 1자리에 넣음

FIFO(First-in First-out)

7,0,1,2,0,3,0,4,2,3,0,3,2,1

찾았는데 없으면 fault > 넣음

즉 701까지는 모두 fault
2 들어갈 때는 가장 먼저 들어온 7을 뺌
0이 이미 있기 때문에 0은 넘어감
3 들어갈때는 0 자리에 넣음

LRU(Least Recently Used): 사용한지 가장 오래된 페이지 참조 문자열을 교체

7,0,1,2,0,3,0,4,2,3,0,3,2,1

701까지 넣고 가장 오래된 7을 2로 교체
0은 그대로 hit
3이 갈 때는 방금 사용한 0이 아닌 1을 교체

LFU(Least Frequently Used): 참조 횟수가 가장 적은 페이지를 교체

7,0,1,2,0,3,0,4,2,3,0,3,2,1

본문에서는 7을 뺐는데 '참조횟수가 같은 경우 가장 최근의 것을 뺀다'는 말이 있으면 1을 빼야함
그런게 없으면 가장 오래된거 빼면 됨
여튼 7자리에 2가 가고
0은 0에 들어가고, 3은 한번 쓴 1자리에 따라 들어감

MFU(Most Frequently Used): 참조 횟수가 가장 많은 페이지를 교체

7,0,1,2,0,3,0,4,2,3,0,3,2,1

701까지는 같고 2가 들어갈 때
7,0,1 모두 한번 참조했는데 가장 오래된 7을 바꿈
0은 0자리로 > 두번 참조가 됨 > 3이 0자리로 들어감 

NUR(Not Used Recently): 최근에 사용되지 않은 페이지를 교체

7,0,1,2,0,3,0,4,2,3,0,3,2,1

7,0,1 같고 7자리에 2, 0자리에 0, 1자리에 3

운영체제에서 이렇게까지 디테일하게 시험이 나올지는 모르겠으나,

혹시나 하는 마음에 작성합니다.

운영체제 페이지 교체 알고리즘에서

LRU(Least Recently Used)하고 NUR(Not Used Recently)하고는 거의 같은 개념입니다.

사실 영어만 보면 똑같아보이죠?

하지만, 구현하는 방식에 차이가 있습니다.

NUR은 최근의 사용여부를 확인하기 위해 각 페이지에 참조비트와 변형비트라는 것을 심어놓습니다. (보통 문제에서는 "각 페이지 당 필요한 2개의 하드웨어 비트를 둔다."로 나옵니다.) NUR은 2개의 비트로만 교체될 페이지를 선정하기 때문에 정확히 언제 참조되었는지를 알기 어려울 수 있습니다.

LRU는 페이지마다 카운터를 가지게해서 타임스탬프를 찍거나 스택의 구조로 구현합니다.

문제에서는 "타이머나 스택을 필요로 한다." 정도로 나옵니다. LRU는 정확히 어떤 페이지가 가장 오래 전에 참조된지를 알 수 있습니다.

그래서 아래와 같이 문제가 나오면 헷갈리지 말고 정답을 작성하셔야합니다.

최근에 쓰이지 않은 페이지는 가까운 미래에도 사용되지 않을 것 같다. 이러한 페이지를 새로 호출하는 페이지와 대체한다. -> NUR, LRU 둘 다 맞음

각 페이지 당 여러 개의 비트를 두어서 판단한다 -> NUR

스택이나 타이머 등을 활용해서 구현한다 -> LRU

둘 다 비슷하기 때문에 헷갈릴 수 있으니, 한 번쯤 봐주시면 좋겠네요.

------------------------------------------------------------

프로세스 관련 약술형 대비

스레싱(Thrashing): 프로세스 처리 시간보다 페이지 교체 시간이 더 많아지는 현상, 비효율적
프로세스 상태의 종류: 생성, 준비, 실행, 대기, 완료, 끝(exit)
스레드(Thread): 프로세스보다는 작은 단위로 독립적으로 수행되는 제어의 흐름, 한개의 프로세스는 여러 스레드를 가지고 있을 수 있다(기출)

교착상태: 여러 개의 프로세스가 특정 자원 할당을 계속 대기하면서 서로 소비 못하는 상황
- 교착상태가 되기 위한 조건: 상호배제, 점유와 대기, 비선점, 환형 대기
- 교착상태 해결방법: 예방, 회피, 발견, 복구

뮤텍스: 하나의 프로세스가 공유 자원에 접근하는 동안, 다른 프로세스가 해당 자원에 접근 못하게 하는 도구
세마포어: 운영체제에서 여러 프로세스가 공유 자원을 사용할 때 문제를 해결하는 동기화 도구(정수값으로 보통 관리)

-----------------------------------------------------------

CPU 스케줄링 알고리즘

CPU의 연산을 기다리는 여러 개의 프로세스가 있다. 숫자는 각 프로세스에 필요한 연산 시간이다.

예) P1=4(단위), P2=2, P3=1

프로세스 도착 순서: P1, P2, P3

이전에는 프로세스를 페이지로 나눠서 쪼개서 어떻게 메모리에 올리는지를 배움
지금은 CPU 자체에 프로세스가 할당됨, 무작정 줄 선다고 해서 되는게 아니라 특정 알고리즘에 의해 프로세스를 수행
그것을 CPU 스케줄링 알고리즘이라고 한다.

선점형: 프로세스가 CPU를 사용 중인데, 더 높은 우선순위의 프로세스가 CPU 연산을 빼앗아가는 것

1) 라운드 로빈(Round-Robin): 모든 프로세스에게 공평하게 시간 할당, 할당된 시간 실행 후 가장 뒤로 세우는 것
'하나 먹었으니까 뒤로 가'

P1(1)-P2(1)-P3(1)-P1(1)-P2(1)-P1(1)-P1(1)
단점: context switching(문맥 교환) 프로세스 교환 시 시간이 소요가 됨, 많은 프로세스를 왔다갔다하면 전체적인 해결 길이가 늘어남

2) SRTF, SRF(Shortest Remaining Time First): 남은 시간이 가장 적은 프로세스를 우선 순위로 연산
실행되고 있는 도중, 남은 시간이 더 짧은 프로세스가 들어오면 그 프로세스 먼저 해결

P3(1)-P2(2)-P1(4)

P2를 사용 중 P4(1) 짜리가 오면 과감히 P2를 버리고 P4를 소모
단점: 짧은 애들이 계속 들어오게 되면 긴 시간을 가지고 있는 애들은 평생 소비되지 않음

비선점형: 한 프로세스가 CPU를 차지하면, 그 프로세스가 끝날 때까지는 다른 프로세스가 점유 못함

1) FCFS(First come, First Serve): 먼저 온 프로세스 순으로 처리하는 방식
비선점형은 한번 CPU를 잡으면 본인이 해결될 때까지 놔주지 않는다.

P1(4)-P2(2)-P3(1)

2) SJF(Shortest Job Fist): 실행시간이 가장 짧은 프로세스 먼저

P3(1)-P2(2)-P1(4)

3) 우선순위(Priority): 프로세스가 가지고 있는 우선순위 별로 먼저 소비하는 방식, 이 경우 시간과 우선순위가 함께 주어짐

우선순위 P2>P1>P3

P2(2)-P1(4)-P3(1)
단점: 우선순위 높은게 들어오면 낮은 우선순위는 죽어도 소비가 안됨


